<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>MLCA Week 5:</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mike Mahoney" />
    <meta name="date" content="2021-06-29" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <script type="application/json" id="xaringanExtra-editable-docid">{"id":"bc331e7ae4994c3dbe14993bae9db5ee","expires":1}</script>
    <script src="libs/himalaya/himalaya.js"></script>
    <script src="libs/js-cookie/js.cookie.js"></script>
    <link href="libs/editable/editable.css" rel="stylesheet" />
    <script src="libs/editable/editable.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/mark.js/mark.min.js"></script>
    <link href="libs/xaringanExtra-search/search.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-search/search.js"></script>
    <script>window.addEventListener('load', function() { window.xeSearch = new RemarkSearch({"position":"bottom-left","caseSensitive":false,"showIcon":true,"autoSearch":true}) })</script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# MLCA Week 5:
## Decision Trees
### Mike Mahoney
### 2021-06-29

---

















class: center, middle

# Decision Trees

---

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt5[

Binary trees give an interesting and often illuminating way of looking at data in classification or regression problems. They should not be used to the exclusion of other methods. We do not claim that they are always better. They do add a flexible nonparametric tool to the data analyst’s arsenal.

.tr[
— [Leo Breiman, Jerome Friedman, Charles J. Stone, R.A. Olshen: Classification and Regression Trees.](https://www.routledge.com/Classification-and-Regression-Trees/Breiman-Friedman-Stone-Olshen/p/book/9780412048418)
]
]

---
class: middle

So far, we've focused almost entirely on traditional parametric regression 
models. Up until now we've stuck with models that require normally distributed 
residuals, linear associations between your predictors and outcome, and 
idnependent, non-correlated predictors.

The problem with these methods is that those assumptions are almost always 
broken. As Tobler's law puts it, everything is related to everything else, 
violating our assumption of independent predictors. 

Especially in the natural 
sciences, those relations tend to be deeply nonlinear, violating our assumption
of linearity as effects saturate or grow exponentially.

---
class: middle

Today we're going to talk about our first truly machine learning algorithm, the 
decision tree, which was specifically designed to help social scientists deal 
with a nonlinear world. 

It's worth taking a second to note the timeline we're walking through. Linear 
regression was first proposed in 1805; the first logistic regression was 
performed in 1838.

Decision trees were introduced for the first time in 1960; the method we'll be
using today was published in 1974, and it's the oldest machine learning method
we'll cover in this course. As a result, we're starting to leave the realm of 
"this is proven to be true" and entering of "this is the current consensus" --
you might find older papers applying these techniques in wildly different ways
than we discuss, or find newer papers advocating for methods we didn't discuss.
I'll attempt to stick to generally accepted facts, but it's worth flagging.

---
class: middle

The last thing I want to point out before we start actually building trees is 
that decision trees are pretty rarely the best choice for any problem. If you're
looking for a highly explainable non-linear model, you might choose general 
additive models instead; to maximize predictive accuracy you'll probably want to 
use random forests or gradient boosting machines.

But random forests and gradient boosting machines are built on top of decision 
trees, so it's important that we discuss them here. However, there's no 
assignment for this week; since the assignments are designed to give you code
templates you might actually use in your own work, and you'll almost never use
decision trees in your own work, it doesn't make sense for us to spend time 
learning how to code them.

---

With all that said, let's get started!

We'll be using the `rpart` package today, alongside the `rpart.plot` package for
visualization:


```r
install.packages("rpart")
install.packages("rpart.plot")
```


```r
library(rpart)
library(rpart.plot)
```

We'll also keep using the same old attrition data:


```r
library(modeldata)
data(attrition)
```

And will use `caret` and `pROC` for assessing our models:


```r
library(caret)
```

```
## Loading required package: lattice
```

```r
library(pROC)
```

```
## Type 'citation("pROC")' for a citation.
```

```
## 
## Attaching package: 'pROC'
```

```
## The following objects are masked from 'package:stats':
## 
##     cov, smooth, var
```

---
class: middle

We're also going to recreate our training and testing splits using the same code 
as before:


```r
set.seed(123)
row_idx &lt;- sample(seq_len(nrow(attrition)), nrow(attrition))
training &lt;- attrition[row_idx &lt; nrow(attrition) * 0.8, ]
testing &lt;- attrition[row_idx &gt;= nrow(attrition) * 0.8, ]
```

To create a decision tree, we can use the `rpart` function from the `rpart` 
package. The syntax is almost exactly like `lm` -- we just need to provide a 
formula and our data:


```r
decision_tree &lt;- rpart(Attrition ~ ., data = training)
```

We can then create a confusion matrix for our classifications just as we did 
with logistic regressions. I've printed this out on the next slide.

---


```r
confusionMatrix(predict(decision_tree, training, type = "class"), 
                training$Attrition, 
                positive = "Yes")
```

```
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  No Yes
##        No  955 122
##        Yes  16  82
##                                           
##                Accuracy : 0.8826          
##                  95% CI : (0.8628, 0.9004)
##     No Information Rate : 0.8264          
##     P-Value [Acc &gt; NIR] : 6.203e-08       
##                                           
##                   Kappa : 0.485           
##                                           
##  Mcnemar's Test P-Value : &lt; 2.2e-16       
##                                           
##             Sensitivity : 0.40196         
##             Specificity : 0.98352         
##          Pos Pred Value : 0.83673         
##          Neg Pred Value : 0.88672         
##              Prevalence : 0.17362         
##          Detection Rate : 0.06979         
##    Detection Prevalence : 0.08340         
##       Balanced Accuracy : 0.69274         
##                                           
##        'Positive' Class : Yes             
## 
```

---

So, we have a decision tree and we've used it to make predictions.

But... what _is_ it? We can get some ideas of what we're working with by 
visualizing it. We'll use the `rpart.plot` function to display our actual model:


```r
rpart(Attrition ~ ., data = training) |&gt; 
  rpart.plot(type = 4)
```

&lt;img src="week_4_imgs/rpartplot.png" width="2160" /&gt;

---

You can think of a decision tree as being effectively a flow chart, which your
data follows until the model has decided how to classify it.

&lt;img src="week_4_imgs/rpartplot.png" width="2160" /&gt;

---

Each of these boxes is called a **node**. We start reading this chart at the very
top of the diagram, at what's called the **root node**. 

&lt;img src="week_4_imgs/rpartplot_root.png" width="2160" /&gt;

---

Because only 17% of our employees in the training data quit (labeled "No"), we 
can see that `rpart` assigns this node "No". Below the label, we can see the 
probability of a data point in this node being a "No" (17%) and the percentage 
of our data that has to go through this node to be classified (100%).

&lt;img src="week_4_imgs/rpartplot_root.png" width="2160" /&gt;

---

If we want to be more accurate than that, we need to start moving down this flow
chart. We'll start off with our first split (sometimes called **branches**), 
which asks each of our observations if their TotalWorkingYears is &gt;= 2.

&lt;img src="week_4_imgs/rpartplot_root.png" width="2160" /&gt;

---

If an employee has been working for more than 2 years, they go down the left 
path (15% probability of quitting, 94% of employees). If an employee has less 
than 2 years, they go down the right (55% probability, 6% of employees).

&lt;img src="week_4_imgs/rpartplot_splits.png" width="2160" /&gt;

---

And so the employees go, down the tree until they land into the buckets -- 
called **leaf nodes** -- at the bottom of the chart. These are our final 
classifications; employees in the blue bins will be classed as "No" and 
employees in the green bins as "Yes".

&lt;img src="week_4_imgs/rpartplot_leaves.png" width="2160" /&gt;

---

And that's a decision tree -- a flow chart with a bunch of yes/no questions that
you follow until you get a final classification. 

&lt;img src="week_4_imgs/rpartplot_leaves.png" width="2160" /&gt;

---

There's a few really interesting features of this algorithm. First off, our 
observations can take different _length_ paths down the decision tree. 

Almost 70% of employees will go through this decision tree in two splits, either 
on the far left or right. 1% will take seven steps.

&lt;img src="week_4_imgs/rpartplot_diffsplits.png" width="2160" /&gt;

---

Similarly, not all variables are used to classify every observation. A lot of 
our variables used in this tree are only used to sort 5% or less of the data. 
The entire tree only uses 10 variables, even though in our formula we said to 
use all 30 predictors in our data frame.

&lt;img src="week_4_imgs/rpartplot_rarevars.png" width="2160" /&gt;

---

And yet, at the same time, our tree uses the variable "TotalWorkingYears" to
create two separate splits.

&lt;img src="week_4_imgs/rpartplot_doubled.png" width="2160" /&gt;

---
class: middle

Decision trees are really interesting because they'll only use variables that 
actually help them make better predictions. If using more variables in split 
rules won't improve accuracy, then the tree won't use more variables. 

At the same time, decision trees will always use the variable which helps them
improve predictive accuracy the most. If a variable is the best choice for 
multiple positions in the tree, it can be used multiple times.

Which leads us to two questions: how do decision trees know which variables to 
use? And how do they know when to stop splitting?

---

To answer the first question, let's think about a tree with only one split.


```r
rpart(Attrition ~ TotalWorkingYears, data = training) |&gt; 
  rpart.plot(type = 4)
```


&lt;img src="week_4_imgs/twy.png" width="2160" /&gt;

---

Because each of our leaf nodes has more than one class in it (they both have 
"Yes" and "No" values), we refer to them as being **impure**. 

Our decision tree will select the variable at each split that creates the most
pure nodes -- or, put another way, the variable which reduces impurity the most.

&lt;img src="week_4_imgs/twy.png" width="2160" /&gt;

---

In order to do that, we need to quantify impurity somehow. The most popular 
method is to calculate the **Gini impurity** values of each node. 

For a given node, the Gini impurity `\(G\)` is equal to:

`$$G = 1 - \left(\operatorname{Probability of yes}\right)^{2} - \left(\operatorname{Probability of no}\right)^{2}$$`

---

We can use that equation to pretty quickly calculate the impurity of each of
our nodes.

&lt;img src="week_4_imgs/twy_impurity_nodes.png" width="2160" /&gt;

---

To calculate the variable which reduces impurity the most for _both_ nodes at
the same time, however, we need to take the weighted average of these node
impurities by multiplying each node's impurity by the proportion of observations
in the node.

&lt;img src="week_4_imgs/twy_impurity_nodes.png" width="2160" /&gt;

---

Because our root node has 100% of the observations, we can just multiply each 
impurity by the percentage of all observations in that bin and then add them 
together, for a total impurity of 0.2694.

&lt;img src="week_4_imgs/twy_impurity_overall.png" width="2160" /&gt;

---

When deciding what variable to use for a split, a decision tree will calculate 
the overall impurity for each possible variable and choose the split with the
lowest value.

When working with continuous variables (like we did above), the decision tree 
will evaluate the value halfway between every level in the variable -- so if 
the column in your data frame has the values 1, 3, and 5, the decision tree will
evaluate splitting using that variable at both 2 and 4.

When working with categorical variables, the decision tree will evaluate each
combination of categories it can and choose the most successful grouping.

And the tree will keep doing this until it has correctly classified all of the
training data, or until it hits some user-specified maximum number of splits or
minimum number of observations in the leaf nodes.

---

Now, why would a user specify a maximum number of splits or minimum number of
observations? Shouldn't we want our tree to classify every observation correctly?

Unfortunately, no. Decision trees are notorious overfitters, and left to their 
own devices will create trees that are so attached to the nuances of your 
training data that they fail to predict any observation they haven't seen before. 

To demonstrate this, let's look at two confusion matrices. The next slide will
have the confusion matrix for this decision tree when predicting the training 
set, and then the slide after that will have the test set confusion matrix.

---


```r
confusionMatrix(predict(decision_tree, training, type = "class"), 
                training$Attrition, 
                positive = "Yes")
```

```
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  No Yes
##        No  955 122
##        Yes  16  82
##                                           
##                Accuracy : 0.8826          
##                  95% CI : (0.8628, 0.9004)
##     No Information Rate : 0.8264          
##     P-Value [Acc &gt; NIR] : 6.203e-08       
##                                           
##                   Kappa : 0.485           
##                                           
##  Mcnemar's Test P-Value : &lt; 2.2e-16       
##                                           
##             Sensitivity : 0.40196         
##             Specificity : 0.98352         
##          Pos Pred Value : 0.83673         
##          Neg Pred Value : 0.88672         
##              Prevalence : 0.17362         
##          Detection Rate : 0.06979         
##    Detection Prevalence : 0.08340         
##       Balanced Accuracy : 0.69274         
##                                           
##        'Positive' Class : Yes             
## 
```

---


```r
confusionMatrix(predict(decision_tree, testing, type = "class"), 
                testing$Attrition, 
                positive = "Yes")
```

```
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction  No Yes
##        No  254  22
##        Yes   8  11
##                                          
##                Accuracy : 0.8983         
##                  95% CI : (0.858, 0.9303)
##     No Information Rate : 0.8881         
##     P-Value [Acc &gt; NIR] : 0.32901        
##                                          
##                   Kappa : 0.3717         
##                                          
##  Mcnemar's Test P-Value : 0.01762        
##                                          
##             Sensitivity : 0.33333        
##             Specificity : 0.96947        
##          Pos Pred Value : 0.57895        
##          Neg Pred Value : 0.92029        
##              Prevalence : 0.11186        
##          Detection Rate : 0.03729        
##    Detection Prevalence : 0.06441        
##       Balanced Accuracy : 0.65140        
##                                          
##        'Positive' Class : Yes            
## 
```

---

Our model which against the training set had 83% positive predictive value and
40% sensitivity all of a sudden has only 57% positive predictive value and 33%
sensitivity! 

When a model performs dramatically better against the training data than the 
test set, that's a sign of **overfitting** -- it means our model fails to 
generalize when predicting data it's never seen before, because it's effectively
"learned" how to categorize each observation in the training data.

Unlike traditional regression, where the solution for overfitting is to remove
weakly correlated variables, with machine learning our solution for overfitting
is generally to change how the model actually works. 

---

For instance, if we want our model to make at most two splits, we can use the
`control` argument in `rpart` to specify that `maxdepth` should equal `2`:


```r
rpart(Attrition ~ ., data = training, control = list(maxdepth = 2)) |&gt; 
  rpart.plot(type = 4)
```

&lt;img src="week_4_imgs/maxdepth.png" width="2120" /&gt;

---

If we wanted instead to make sure that every leaf had at least 100 observations,
we could set the `minbucket` argument:


```r
rpart(Attrition ~ ., data = training, control = list(minbucket = 100)) |&gt; 
  rpart.plot(type = 4)
```

&lt;img src="week_4_imgs/minbucket.png" width="2160" /&gt;

---

We call values like `maxdepth` and `minbucket` which control the behavior of our 
algorithm **hyperparameters**. 

Just like the coefficients in a linear regression, the precise values of each 
hyperparameter can be very important in influencing our predictions; unlike 
coefficients, however, hyperparameters can't be automatically determined when 
fitting your model to the training data.

Instead, the optimal hyperparameter values have to be determined separately from
fitting the model. While there might be some common default values that people
start with, generally speaking finding the right hyperparameter values requires
a process of trial and error, eventually choosing the values that give you the
best results against your validation set.

That's all that we'll talk about hyperparameters today; we'll spend more time 
talking about how to find the best values in two weeks.

---

In addition to being nasty overfitters, decision trees have one more major 
drawback. For instance, here's the histogram of probabilities predicted by a
full logistic model:

![](week_5_slides_files/figure-html/unnamed-chunk-32-1.png)&lt;!-- --&gt;

And now, here's the histogram of probabilities predicted by our decision tree:

![](week_5_slides_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

The logistic graph looks like what we might expect -- a smooth curve, 
asymptotically approaching 0 as you get towards 100% quitting. The decision tree
graph does not.

---

That's because, for a decision tree, your probability of being "Yes" is equal to
the percentage of your bin that is "Yes". This means that our tree, which has
15 leaf nodes, is only capable of predicting at most 15 different values. 

&lt;img src="week_4_imgs/rpartplot.png" width="2160" /&gt;

---

This can lead to some very weird prediction surfaces -- while traditional 
methods like logistic regression create smooth transitions in probability, 
decision trees are known for creating odd surfaces with hard right angles at
their splits.

For instance, 

![](week_5_slides_files/figure-html/unnamed-chunk-35-1.png)&lt;!-- --&gt;

![](week_5_slides_files/figure-html/unnamed-chunk-36-1.png)&lt;!-- --&gt;

---

And while we've focused today entirely on classification, I want to point out 
that all the same techniques can be applied to regression as well. For instance,
if we load our Ames housing data:


```r
library(AmesHousing)
ames &lt;- make_ames()
row_idx &lt;- sample(seq_len(nrow(ames)), nrow(ames))
training &lt;- ames[row_idx &lt; nrow(ames) * 0.8, ]
testing &lt;- ames[row_idx &gt;= nrow(ames) * 0.8, ]
```

We can use the exact same syntax to fit a regression model:


```r
ames_tree &lt;- rpart(Sale_Price ~ ., data = training)
```

Which we can then calculate the holdout set RMSE of via:


```r
sqrt(mean((predict(ames_tree, testing) - testing$Sale_Price)^2))
```

```
## [1] 35849.42
```

That's an improvement from the last linear model we fit to the same data!

---

And just like with classification, our model will only be able to predict a set
number of values. For instance, here's what the prediction surface of a decision
tree trained using only two variables, `Year_Built` and `Gr_Liv_Area`, looks
like:


```r
small_model &lt;- rpart(Sale_Price ~ Gr_Liv_Area + Year_Built, data = training)

decision_grid &lt;- expand.grid(
  Gr_Liv_Area = seq(
    min(training$Gr_Liv_Area), 
    max(training$Gr_Liv_Area), 
    length.out = 100),
  Year_Built = seq(
    min(training$Year_Built), 
    max(training$Year_Built), 
    length.out = 100)
)

decision_grid$Sale_Price &lt;- predict(small_model, decision_grid)

ggplot(decision_grid, aes(Gr_Liv_Area, Year_Built, fill = Sale_Price)) + 
  geom_raster() + 
  ggtitle("Decision tree regression")
```

![](week_5_slides_files/figure-html/unnamed-chunk-40-1.png)&lt;!-- --&gt;

---

These weird prediction surfaces can still generate really good predictions. But
it does make model interpretation a bit harder -- in the last graph, for 
instance, we could say that homes built after 1980 sell for more money, as well 
as homes built after 1950 if they're under 1,500 square feet, and also after
2000 if they're between 1,600 and 2,000 square feet, and --

Decision trees are our first machine learning algorithm in this course, and they
bridge the gap from estimation methods (such as linear regression) to pure 
predictive algorithms like we'll focus on for the rest of the semester. These 
methods trade model interpretability for flexibility -- we don't need to worry
about any of the linear model assumptions with these tools -- and predictive 
accuracy. 

Next week, we'll make the jump all the way into pure prediction with random 
forests. 

---

.bg-washed-green.b--dark-green.ba.bw2.br3.shadow-5.ph4.mt5[

Binary trees give an interesting and often illuminating way of looking at data in classification or regression problems. They should not be used to the exclusion of other methods. We do not claim that they are always better. They do add a flexible nonparametric tool to the data analyst’s arsenal.

.tr[
— [Leo Breiman, Jerome Friedman, Charles J. Stone, R.A. Olshen: Classification and Regression Trees.](https://www.routledge.com/Classification-and-Regression-Trees/Breiman-Friedman-Stone-Olshen/p/book/9780412048418)
]
]

---
class: middle center title-slide

## No assignment this week
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
