<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>MLCA Week 4:</title>
    <meta charset="utf-8" />
    <meta name="author" content="Mike Mahoney" />
    <meta name="date" content="2021-09-22" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <script type="application/json" id="xaringanExtra-editable-docid">{"id":"x223ad27d1444a42b6dddf05b3ef7c4d","expires":1}</script>
    <script src="libs/himalaya/himalaya.js"></script>
    <script src="libs/js-cookie/js.cookie.js"></script>
    <link href="libs/editable/editable.css" rel="stylesheet" />
    <script src="libs/editable/editable.js"></script>
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <script src="libs/mark.js/mark.min.js"></script>
    <link href="libs/xaringanExtra-search/search.css" rel="stylesheet" />
    <script src="libs/xaringanExtra-search/search.js"></script>
    <script>window.addEventListener('load', function() { window.xeSearch = new RemarkSearch({"position":"bottom-left","caseSensitive":false,"showIcon":true,"autoSearch":true}) })</script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/xaringanExtra-extra-styles/xaringanExtra-extra-styles.css" rel="stylesheet" />
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# MLCA Week 4:
## Imbalanced Classification
### Mike Mahoney
### 2021-09-22

---

















class: center, middle

# Classification, Continued

---
class: middle

Last week we started talking about classification using logistic regression, 
using a very simple model to predict employee attrition as a function of age.

That simple model had ~89% overall accuracy -- not because it was highly 
predictive, but simply because ~89% of employees didn't quit, so our model could
score high by assuming no one ever left.

We're going to talk this week about ways to deal with that problem.

---
class: middle

Let's start by loading packages and recreating our dataframes:


```r
library(modeldata)
library(caret)
library(pROC)
```

&lt;br /&gt;

First, we'll load the `attrition` data and clean it, using the same code as last
week:


```r
data(attrition)
attrition_cleaned &lt;- attrition |&gt; 
  mutate(across(where(is.factor), as.character)) |&gt;
  mutate(Attrition = recode(Attrition, "Yes" = 1, "No" = 0))
```

&lt;br /&gt;

And then recreate our training and testing splits using the same code as before:


```r
set.seed(123)
row_idx &lt;- sample(seq_len(nrow(attrition_cleaned)), nrow(attrition_cleaned))
training &lt;- attrition_cleaned[row_idx &lt; nrow(attrition_cleaned) * 0.8, ]
testing &lt;- attrition_cleaned[row_idx &gt;= nrow(attrition_cleaned) * 0.8, ]
```

---
class: middle

Last week we focused on an extremely simple model, with only Age as a 
predictor. 

&lt;br /&gt;

This week, let's go ahead and use all the predictors in the data 
frame instead:


```r
attrition_model &lt;- glm(Attrition ~ ., 
                       attrition_cleaned, 
                       family = "binomial")
```

&lt;br /&gt;

And let's use a probability threshold of 0.5 to classify our predictions:


```r
testing$prediction &lt;- predict(attrition_model, 
                              testing, 
                              type = "response")

testing$prediction &lt;- round(testing$prediction)
```

---

We can use these predictions to calculate a new confusion matrix:


```r
attrition_confusion &lt;- confusionMatrix(
  factor(testing$prediction),
  factor(testing$Attrition),
  positive = "1"
)
attrition_confusion
```

```
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction   0   1
##          0 254  18
##          1   8  15
##                                           
##                Accuracy : 0.9119          
##                  95% CI : (0.8735, 0.9416)
##     No Information Rate : 0.8881          
##     P-Value [Acc &gt; NIR] : 0.11251         
##                                           
##                   Kappa : 0.4887          
##                                           
##  Mcnemar's Test P-Value : 0.07756         
##                                           
##             Sensitivity : 0.45455         
##             Specificity : 0.96947         
##          Pos Pred Value : 0.65217         
##          Neg Pred Value : 0.93382         
##              Prevalence : 0.11186         
##          Detection Rate : 0.05085         
##    Detection Prevalence : 0.07797         
##       Balanced Accuracy : 0.71201         
##                                           
##        'Positive' Class : 1               
## 
```

---

As well as to take a look at our ROC curve and AUC:


```r
attrition_roc &lt;- roc(
  testing$Attrition,
  predict(attrition_model, testing, type = "response")
)
```

.center[

```r
plot(attrition_roc)
```

![](week_4_slides_files/figure-html/unnamed-chunk-8-1.png)&lt;!-- --&gt;
]


```r
auc(attrition_roc)
```

```
## Area under the curve: 0.8958
```

---
class: middle

Even though our overall accuracy has barely changed -- 91% versus 89% -- we can
tell from our sensitivity and AUC values that this model is much, much better at
predicting which employees will quit. Meanwhile, our high specificity suggests 
we haven't gotten _that_ much worse at predicting which employees will stay.

&lt;br /&gt;

But we're still doing _much_ better at predicting employees who will stay than
those who leave -- our sensitivity is about 45%, while our specificity is at 96%.

&lt;br /&gt;

Why does our new model, with so many more predictors to draw from, still mostly
ignore "positive" cases?

---
class: middle

The answer is that there just aren't enough "positive" cases in our training 
data:


```r
table(training$Attrition)
```

```
## 
##   0   1 
## 971 204
```

&lt;br /&gt;

Our data set has almost 5 times more "No" values (0s) for attrition than "Yes"es 
(1s), so models which are super accurate on "No" and not very accurate on "Yes" 
can be just as accurate overall as a model trying its best on both classes.

&lt;br /&gt;

Our data has **imbalanced classes**, and this problem is an example 
of **imbalanced classification**. 

---
class: middle

We have a handful of ways of dealing with imbalanced classes. One that we've 
already talked about is to change our probability threshold using our ROC curve.

&lt;br /&gt;

Another is to _weight_ our observations when we're fitting our model. We want
our model to care about "Yes" just as much as "No", even though there are almost
5 times as many "No" values to predict. 

&lt;br /&gt;

In this situation, we can provide weights to our model to signal that every 
"Yes" should be "worth" 5 times as much as each "No", so that in total both 
classes are "worth" the same amount to the model.

---
class: middle

To put this into practice, we'd first want to create a "weight" column in our 
training data set. We'll set the weights of "No" values to 1 and "Yes" to 5, to
try and balance our classes:


```r
training_weights &lt;- ifelse(training$Attrition, 5, 1)

training |&gt; 
  mutate(weight = training_weights) |&gt; 
  select(Age, Attrition, weight) |&gt; 
  head()
```

```
##   Age Attrition weight
## 1  41         1      5
## 2  49         0      1
## 4  37         1      5
## 5  33         0      1
## 7  27         0      1
## 8  32         0      1
```

---
class: middle

We then need to provide this new "weight" column to the "weights" argument of
`glm`:


```r
weighted_model &lt;- glm(
  Attrition ~ ., 
  training,
  weights = training_weights, 
  family = "binomial")
```

&lt;br /&gt;

Then we make our predictions as we did originally: calculate the probability 
of each employee quitting, then use a probability threshold of 0.5 to classify
employees into "Yes" and "No" groups:


```r
testing$prediction &lt;- predict(weighted_model, testing, type = "response")
testing$prediction &lt;- round(testing$prediction)
```

Let's take a look at our confusion matrix...

---


```r
confusionMatrix(factor(testing$prediction), 
                factor(testing$Attrition), 
                positive = "1")
```

```
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction   0   1
##          0 206   8
##          1  56  25
##                                           
##                Accuracy : 0.7831          
##                  95% CI : (0.7316, 0.8287)
##     No Information Rate : 0.8881          
##     P-Value [Acc &gt; NIR] : 1               
##                                           
##                   Kappa : 0.3325          
##                                           
##  Mcnemar's Test P-Value : 4.228e-09       
##                                           
##             Sensitivity : 0.75758         
##             Specificity : 0.78626         
##          Pos Pred Value : 0.30864         
##          Neg Pred Value : 0.96262         
##              Prevalence : 0.11186         
##          Detection Rate : 0.08475         
##    Detection Prevalence : 0.27458         
##       Balanced Accuracy : 0.77192         
##                                           
##        'Positive' Class : 1               
## 
```

---

And take a look at our ROC curve and AUC:


```r
weighted_roc &lt;- roc(
  testing$Attrition,
  predict(weighted_model, testing, type = "response")
)
```

.center[

```r
plot(weighted_roc)
```

![](week_4_slides_files/figure-html/unnamed-chunk-16-1.png)&lt;!-- --&gt;
]


```r
auc(weighted_roc)
```

```
## Area under the curve: 0.857
```

---
class: middle

So, to summarize, our weighted model has dramatically higher sensitivity than 
our original, at the cost of lower specificity and AUC. 

&lt;br /&gt; 

As we discussed last week, whether or not this is a _good_ thing strongly 
depends upon your goals for the model and what trade-offs you're willing to make.


&lt;br /&gt; 

If you're happy to accept a more sensitive model at the cost of specificity -- 
to detect more positives overall even if it means you have more false 
positives -- then this is definitely an improvement. 

&lt;br /&gt;

It might even make sense to weight the positives slightly more -- to 
intentionally imbalance your classes!

---

A second way we might deal with imbalanced classes is to **resample** our data.

To talk about resampling, it might make sense for us to talk first about 
sampling itself. Let's say we're interested in the heights of men across the USA.

The heights for every man in the country might look something like this:


```r
heights &lt;- rnorm(1e5, mean = 68, sd = 4)

qplot(heights)
```

![](week_4_slides_files/figure-html/unnamed-chunk-18-1.png)&lt;!-- --&gt;

---

But of course, it's rather expensive to measure every person in the country.

Instead of doing that, most of the time we work with **samples** from our larger
population. Ideally, our samples are chosen entirely at random, and each person
is measured at most one time.

If we only measure a few people, then our sample won't look anything like the 
population:


```r
sampled_heights &lt;- sample(heights, 10)

qplot(sampled_heights)
```

![](week_4_slides_files/figure-html/unnamed-chunk-19-1.png)&lt;!-- --&gt;
---

But as we take more and more measurements, over time our measurements will start
looking a lot more like the entire population:


```r
sampled_heights &lt;- sample(heights, 1e4)

qplot(sampled_heights)
```

![](week_4_slides_files/figure-html/unnamed-chunk-20-1.png)&lt;!-- --&gt;

---

What if we took a sample that's larger than the population?

Well, we'd need to break our rule that each person can only be measured once. 
We'd need to start taking measurements _with replacement_. We're still sampling
at random, so any given person might be sampled once, more than once, or not at
all.

If we do that, our super-sized sample looks pretty much exactly like the
population:


```r
sampled_heights &lt;- sample(heights, 1e6, replace = TRUE)

qplot(sampled_heights)
```

![](week_4_slides_files/figure-html/unnamed-chunk-21-1.png)&lt;!-- --&gt;

---
class: middle

This is the basic idea behind resampling methods. By taking samples with 
replacement from our sample, we can increase our effective sample size while 
still resembling the larger population, all without needing to go and collect
new data.

&lt;br /&gt;

Of course, this method depends on our original sample being sufficiently 
representative of the population. If that wasn't true, though, you also wouldn't
be able to fit good models _without_ resampling.

&lt;br /&gt;

But we can use this approach to increase the number of "Yes" observations we have
in our data set, in order to balance our classes and make better predictions.

---
class: middle 

To do that, we'd first split our training data into positive and negative pieces:


```r
positive_training &lt;- training[training$Attrition == 1, ]
negative_training &lt;- training[training$Attrition == 0, ]
```

Then we'd want to randomly select rows from our positive sample until we had the
same number of positive observations as negatives.

We can resample our positive sample to have five times the number of 
observations like this:


```r
n_pos &lt;- nrow(positive_training)

resampled_positives &lt;- sample(1:n_pos, 
                                 size = 5 * n_pos, 
                                 replace = TRUE)

resampled_positives &lt;- positive_training[resampled_positives, ]
```

---

Then we can combine our resampled positive dataframe with the original negative 
dataframe to get a new, evenly balanced data set:


```r
resampled_training &lt;- rbind(
  negative_training,
  resampled_positives
)
```

We can confirm that our classes are now balanced:


```r
table(resampled_training$Attrition)
```

```
## 
##    0    1 
##  971 1020
```

&lt;br /&gt;

If anything, we've actually added slightly too many "yes" cases to this data set!

Now let's go ahead and fit a new model on the resampled data:


```r
resampled_model &lt;- glm(
  Attrition ~ ., 
  resampled_training,
  family = "binomial")
```

---
class: middle

Then we make our predictions as we did originally: calculate the probability 
of each employee quitting, then use a probability threshold of 0.5 to classify
employees into "Yes" and "No" groups:


```r
testing$prediction &lt;- predict(resampled_model, 
                              testing, 
                              type = "response")

testing$prediction &lt;- round(testing$prediction)
```

Let's take a look at our confusion matrix...

---


```r
confusionMatrix(factor(testing$prediction), 
                factor(testing$Attrition), 
                positive = "1")
```

```
## Confusion Matrix and Statistics
## 
##           Reference
## Prediction   0   1
##          0 202   8
##          1  60  25
##                                           
##                Accuracy : 0.7695          
##                  95% CI : (0.7172, 0.8163)
##     No Information Rate : 0.8881          
##     P-Value [Acc &gt; NIR] : 1               
##                                           
##                   Kappa : 0.313           
##                                           
##  Mcnemar's Test P-Value : 6.224e-10       
##                                           
##             Sensitivity : 0.75758         
##             Specificity : 0.77099         
##          Pos Pred Value : 0.29412         
##          Neg Pred Value : 0.96190         
##              Prevalence : 0.11186         
##          Detection Rate : 0.08475         
##    Detection Prevalence : 0.28814         
##       Balanced Accuracy : 0.76428         
##                                           
##        'Positive' Class : 1               
## 
```

---

And take a look at our ROC curve and AUC:


```r
resampled_roc &lt;- roc(
  testing$Attrition,
  predict(resampled_model, testing, type = "response")
)
```

.center[

```r
plot(resampled_roc)
```

![](week_4_slides_files/figure-html/unnamed-chunk-30-1.png)&lt;!-- --&gt;
]


```r
auc(resampled_roc)
```

```
## Area under the curve: 0.8498
```

---
class: middle

Overall, this model is pretty similar in accuracy and AUC to the weighted 
version. 

That's not just coincidence; both of these methods were aiming at effectively 
increasing the importance of "Yes" values to the model by 500%, so it makes sense
for two methods with the same goals to have similar outcomes.

When you're able to specify weights, that's often a better way to adjust for 
imbalanced classes than resampling; it makes your intent more obvious and is 
computationally more efficient. But often, model
implementations won't provide obvious ways to weight your classes, requiring you
to take matters into your own hands.

---

Note also these methods produce slightly different probabilities:

![](week_4_slides_files/figure-html/unnamed-chunk-32-1.png)&lt;!-- --&gt;

![](week_4_slides_files/figure-html/unnamed-chunk-33-1.png)&lt;!-- --&gt;

![](week_4_slides_files/figure-html/unnamed-chunk-34-1.png)&lt;!-- --&gt;

---
class: middle

These approaches can be used even with more complex models to try and
deal with imbalanced classes. 

&lt;br /&gt;

While new methods are being proposed every day --
imbalanced classification problems are one of the most fundamental unsolved 
problems in prediction -- these three should be generally applicable to any 
real-world classification problem you have to work with.

---
class: middle

One final note: I want to highlight that both weighting and bootstrapping used
the class abundances from the _training set_. 

&lt;br /&gt;

You should not be setting weights based on the prevalence of classes in the test 
set; as we mentioned week 2, the test data should be completely unknown to both 
the model and the modeler. 

&lt;br /&gt;

That means you shouldn't even _know_ what the class abundances are in the test 
set, if you can avoid it. 

&lt;br /&gt;

That's it for this week. Next week we leave the world of traditional statistics
and start in with our first pure prediction algorithm: the decision tree.

---
class: middle center title-slide

## Assignment 4

(Due week 5)

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
